{
  "api": {
    "name": "BleClientInterface",
    "slug": "bleclientinterface",
    "docs": "",
    "tags": [],
    "methods": [
      {
        "name": "initialize",
        "signature": "(options?: InitializeOptions | undefined) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "",
            "type": "InitializeOptions | undefined"
          }
        ],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Initialize Bluetooth Low Energy (BLE). If it fails, BLE might be unavailable on this device.\nOn **Android** it will ask for the location permission. On **iOS** it will ask for the Bluetooth permission.\nFor an example, see [usage](#usage).",
        "complexTypes": [
          "InitializeOptions"
        ],
        "slug": "initialize"
      },
      {
        "name": "isEnabled",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "Reports whether Bluetooth is enabled on this device.\nAlways returns `true` on **web**.",
        "complexTypes": [],
        "slug": "isenabled"
      },
      {
        "name": "forceEnable",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Enable Bluetooth.\nOnly available on **Android**.",
        "complexTypes": [],
        "slug": "forceenable"
      },
      {
        "name": "disable",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Disable Bluetooth.\nOnly available on **Android**.",
        "complexTypes": [],
        "slug": "disable"
      },
      {
        "name": "startEnabledNotifications",
        "signature": "(callback: (value: boolean) => void) => Promise<void>",
        "parameters": [
          {
            "name": "callback",
            "docs": "Callback function to use when the Bluetooth state changes.",
            "type": "(value: boolean) => void"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "callback Callback function to use when the Bluetooth state changes."
          }
        ],
        "docs": "Register a callback function that will be invoked when Bluetooth is enabled (true) or disabled (false) on this device.\nNot available on **web** (the callback will never be invoked).",
        "complexTypes": [],
        "slug": "startenablednotifications"
      },
      {
        "name": "stopEnabledNotifications",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Stop the enabled notifications registered with `startEnabledNotifications`.",
        "complexTypes": [],
        "slug": "stopenablednotifications"
      },
      {
        "name": "isLocationEnabled",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "Reports whether Location Services are enabled on this device.\nOnly available on **Android**.",
        "complexTypes": [],
        "slug": "islocationenabled"
      },
      {
        "name": "openLocationSettings",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Open Location settings.\nOnly available on **Android**.",
        "complexTypes": [],
        "slug": "openlocationsettings"
      },
      {
        "name": "openBluetoothSettings",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Open Bluetooth settings.\nOnly available on **Android**.",
        "complexTypes": [],
        "slug": "openbluetoothsettings"
      },
      {
        "name": "openAppSettings",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Open App settings.\nNot available on **web**.\nOn **iOS** when a user declines the request to use Bluetooth on the first call of `initialize`, it is not possible\nto request for Bluetooth again from within the app. In this case Bluetooth has to be enabled in the app settings\nfor the app to be able use it.",
        "complexTypes": [],
        "slug": "openappsettings"
      },
      {
        "name": "setDisplayStrings",
        "signature": "(displayStrings: DisplayStrings) => Promise<void>",
        "parameters": [
          {
            "name": "displayStrings",
            "docs": "",
            "type": "DisplayStrings"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "displayStrings"
          }
        ],
        "docs": "Set the strings that are displayed in the `requestDevice` dialog.",
        "complexTypes": [
          "DisplayStrings"
        ],
        "slug": "setdisplaystrings"
      },
      {
        "name": "requestDevice",
        "signature": "(options?: RequestBleDeviceOptions | undefined) => Promise<BleDevice>",
        "parameters": [
          {
            "name": "options",
            "docs": "Device filters, see [RequestBleDeviceOptions](#RequestBleDeviceOptions)",
            "type": "RequestBleDeviceOptions | undefined"
          }
        ],
        "returns": "Promise<BleDevice>",
        "tags": [
          {
            "name": "param",
            "text": "options Device filters, see [RequestBleDeviceOptions](#RequestBleDeviceOptions)"
          }
        ],
        "docs": "Request a peripheral BLE device to interact with. This will scan for available devices according to the filters in the options and show a dialog to pick a device.\nFor an example, see [usage](#usage).",
        "complexTypes": [
          "BleDevice",
          "RequestBleDeviceOptions"
        ],
        "slug": "requestdevice"
      },
      {
        "name": "requestLEScan",
        "signature": "(options: RequestBleDeviceOptions, callback: (result: ScanResult) => void) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "",
            "type": "RequestBleDeviceOptions"
          },
          {
            "name": "callback",
            "docs": "",
            "type": "(result: ScanResult) => void"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options"
          },
          {
            "name": "param",
            "text": "callback"
          }
        ],
        "docs": "Start scanning for BLE devices to interact with according to the filters in the options. The callback will be invoked on each device that is found.\nScanning will continue until `stopLEScan` is called. For an example, see [usage](#usage).\n**NOTE**: Use with care on **web** platform, the required API is still behind a flag in most browsers.",
        "complexTypes": [
          "RequestBleDeviceOptions",
          "ScanResult"
        ],
        "slug": "requestlescan"
      },
      {
        "name": "stopLEScan",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [],
        "docs": "Stop scanning for BLE devices. For an example, see [usage](#usage).",
        "complexTypes": [],
        "slug": "stoplescan"
      },
      {
        "name": "getDevices",
        "signature": "(deviceIds: string[]) => Promise<BleDevice[]>",
        "parameters": [
          {
            "name": "deviceIds",
            "docs": "List of device IDs, e.g. saved from a previous app run. No used on web.",
            "type": "string[]"
          }
        ],
        "returns": "Promise<BleDevice[]>",
        "tags": [
          {
            "name": "param",
            "text": "deviceIds List of device IDs, e.g. saved from a previous app run. No used on web."
          }
        ],
        "docs": "On iOS and web, if you want to connect to a previously connected device without scanning first, you can use `getDevice`.\nUses [retrievePeripherals](https://developer.apple.com/documentation/corebluetooth/cbcentralmanager/1519127-retrieveperipherals) on iOS and\n[getDevices](https://developer.mozilla.org/en-US/docs/Web/API/Bluetooth/getDevices) on web.\nOn Android, you can directly connect to the device with the deviceId.",
        "complexTypes": [
          "BleDevice"
        ],
        "slug": "getdevices"
      },
      {
        "name": "getConnectedDevices",
        "signature": "(services: string[]) => Promise<BleDevice[]>",
        "parameters": [
          {
            "name": "services",
            "docs": "List of services to filter the devices by. If no service is specified, no devices will be returned. Only applies to iOS.",
            "type": "string[]"
          }
        ],
        "returns": "Promise<BleDevice[]>",
        "tags": [
          {
            "name": "param",
            "text": "services List of services to filter the devices by. If no service is specified, no devices will be returned. Only applies to iOS."
          }
        ],
        "docs": "Get a list of currently connected devices.\nUses [retrieveConnectedPeripherals](https://developer.apple.com/documentation/corebluetooth/cbcentralmanager/1518924-retrieveconnectedperipherals) on iOS,\n[getConnectedDevices](https://developer.android.com/reference/android/bluetooth/BluetoothManager#getConnectedDevices(int)) on Android\nand [getDevices](https://developer.mozilla.org/en-US/docs/Web/API/Bluetooth/getDevices) on web.",
        "complexTypes": [
          "BleDevice"
        ],
        "slug": "getconnecteddevices"
      },
      {
        "name": "connect",
        "signature": "(deviceId: string, onDisconnect?: ((deviceId: string) => void) | undefined, options?: TimeoutOptions | undefined) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "onDisconnect",
            "docs": "Optional disconnect callback function that will be used when the device disconnects",
            "type": "((deviceId: string) => void) | undefined"
          },
          {
            "name": "options",
            "docs": "Options for plugin call",
            "type": "TimeoutOptions | undefined"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "onDisconnect Optional disconnect callback function that will be used when the device disconnects"
          },
          {
            "name": "param",
            "text": "options Options for plugin call"
          }
        ],
        "docs": "Connect to a peripheral BLE device. For an example, see [usage](#usage).",
        "complexTypes": [
          "TimeoutOptions"
        ],
        "slug": "connect"
      },
      {
        "name": "createBond",
        "signature": "(deviceId: string) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          }
        ],
        "docs": "Create a bond with a peripheral BLE device.\nOnly available on **Android**. On iOS bonding is handled by the OS.",
        "complexTypes": [],
        "slug": "createbond"
      },
      {
        "name": "isBonded",
        "signature": "(deviceId: string) => Promise<boolean>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          }
        ],
        "returns": "Promise<boolean>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          }
        ],
        "docs": "Report whether a peripheral BLE device is bonded.\nOnly available on **Android**. On iOS bonding is handled by the OS.",
        "complexTypes": [],
        "slug": "isbonded"
      },
      {
        "name": "disconnect",
        "signature": "(deviceId: string) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          }
        ],
        "docs": "Disconnect from a peripheral BLE device. For an example, see [usage](#usage).",
        "complexTypes": [],
        "slug": "disconnect"
      },
      {
        "name": "getServices",
        "signature": "(deviceId: string) => Promise<BleService[]>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          }
        ],
        "returns": "Promise<BleService[]>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          }
        ],
        "docs": "Get services, characteristics and descriptors of a device.",
        "complexTypes": [
          "BleService"
        ],
        "slug": "getservices"
      },
      {
        "name": "readRssi",
        "signature": "(deviceId: string) => Promise<number>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          }
        ],
        "returns": "Promise<number>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          }
        ],
        "docs": "Read the RSSI value of a connected device.\nNot available on web.",
        "complexTypes": [],
        "slug": "readrssi"
      },
      {
        "name": "read",
        "signature": "(deviceId: string, service: string, characteristic: string, options?: TimeoutOptions | undefined) => Promise<DataView>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "service",
            "docs": "UUID of the service (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "characteristic",
            "docs": "UUID of the characteristic (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "options",
            "docs": "Options for plugin call",
            "type": "TimeoutOptions | undefined"
          }
        ],
        "returns": "Promise<DataView>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "service UUID of the service (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "characteristic UUID of the characteristic (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "options Options for plugin call"
          }
        ],
        "docs": "Read the value of a characteristic. For an example, see [usage](#usage).",
        "complexTypes": [
          "DataView",
          "TimeoutOptions"
        ],
        "slug": "read"
      },
      {
        "name": "write",
        "signature": "(deviceId: string, service: string, characteristic: string, value: DataView, options?: TimeoutOptions | undefined) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "service",
            "docs": "UUID of the service (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "characteristic",
            "docs": "UUID of the characteristic (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "value",
            "docs": "The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])",
            "type": "DataView"
          },
          {
            "name": "options",
            "docs": "Options for plugin call",
            "type": "TimeoutOptions | undefined"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "service UUID of the service (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "characteristic UUID of the characteristic (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "value The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])"
          },
          {
            "name": "param",
            "text": "options Options for plugin call"
          }
        ],
        "docs": "Write a value to a characteristic. For an example, see [usage](#usage).",
        "complexTypes": [
          "DataView",
          "TimeoutOptions"
        ],
        "slug": "write"
      },
      {
        "name": "writeWithoutResponse",
        "signature": "(deviceId: string, service: string, characteristic: string, value: DataView, options?: TimeoutOptions | undefined) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "service",
            "docs": "UUID of the service (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "characteristic",
            "docs": "UUID of the characteristic (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "value",
            "docs": "The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])",
            "type": "DataView"
          },
          {
            "name": "options",
            "docs": "Options for plugin call",
            "type": "TimeoutOptions | undefined"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "service UUID of the service (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "characteristic UUID of the characteristic (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "value The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])"
          },
          {
            "name": "param",
            "text": "options Options for plugin call"
          }
        ],
        "docs": "Write a value to a characteristic without waiting for a response.",
        "complexTypes": [
          "DataView",
          "TimeoutOptions"
        ],
        "slug": "writewithoutresponse"
      },
      {
        "name": "readDescriptor",
        "signature": "(deviceId: string, service: string, characteristic: string, descriptor: string, options?: TimeoutOptions | undefined) => Promise<DataView>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "service",
            "docs": "UUID of the service (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "characteristic",
            "docs": "UUID of the characteristic (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "descriptor",
            "docs": "UUID of the descriptor (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "options",
            "docs": "Options for plugin call",
            "type": "TimeoutOptions | undefined"
          }
        ],
        "returns": "Promise<DataView>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "service UUID of the service (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "characteristic UUID of the characteristic (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "descriptor UUID of the descriptor (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "options Options for plugin call"
          }
        ],
        "docs": "Read the value of a descriptor.",
        "complexTypes": [
          "DataView",
          "TimeoutOptions"
        ],
        "slug": "readdescriptor"
      },
      {
        "name": "writeDescriptor",
        "signature": "(deviceId: string, service: string, characteristic: string, descriptor: string, value: DataView, options?: TimeoutOptions | undefined) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "service",
            "docs": "UUID of the service (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "characteristic",
            "docs": "UUID of the characteristic (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "descriptor",
            "docs": "UUID of the descriptor (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "value",
            "docs": "The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])",
            "type": "DataView"
          },
          {
            "name": "options",
            "docs": "Options for plugin call",
            "type": "TimeoutOptions | undefined"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "service UUID of the service (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "characteristic UUID of the characteristic (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "descriptor UUID of the descriptor (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "value The value to write as a DataView. To create a DataView from an array of numbers, there is a helper function, e.g. numbersToDataView([1, 0])"
          },
          {
            "name": "param",
            "text": "options Options for plugin call"
          }
        ],
        "docs": "Write a value to a descriptor.",
        "complexTypes": [
          "DataView",
          "TimeoutOptions"
        ],
        "slug": "writedescriptor"
      },
      {
        "name": "startNotifications",
        "signature": "(deviceId: string, service: string, characteristic: string, callback: (value: DataView) => void) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "service",
            "docs": "UUID of the service (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "characteristic",
            "docs": "UUID of the characteristic (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "callback",
            "docs": "Callback function to use when the value of the characteristic changes",
            "type": "(value: DataView) => void"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "service UUID of the service (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "characteristic UUID of the characteristic (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "callback Callback function to use when the value of the characteristic changes"
          }
        ],
        "docs": "Start listening to changes of the value of a characteristic.\nNote that you should only start the notifications once per characteristic in your app and share the data and\nnot call `startNotifications` in every component that needs the data.\nFor an example, see [usage](#usage).",
        "complexTypes": [
          "DataView"
        ],
        "slug": "startnotifications"
      },
      {
        "name": "stopNotifications",
        "signature": "(deviceId: string, service: string, characteristic: string) => Promise<void>",
        "parameters": [
          {
            "name": "deviceId",
            "docs": "The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))",
            "type": "string"
          },
          {
            "name": "service",
            "docs": "UUID of the service (see [UUID format](#uuid-format))",
            "type": "string"
          },
          {
            "name": "characteristic",
            "docs": "UUID of the characteristic (see [UUID format](#uuid-format))",
            "type": "string"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "deviceId The ID of the device to use (obtained from [requestDevice](#requestDevice) or [requestLEScan](#requestLEScan))"
          },
          {
            "name": "param",
            "text": "service UUID of the service (see [UUID format](#uuid-format))"
          },
          {
            "name": "param",
            "text": "characteristic UUID of the characteristic (see [UUID format](#uuid-format))"
          }
        ],
        "docs": "Stop listening to the changes of the value of a characteristic. For an example, see [usage](#usage).",
        "complexTypes": [],
        "slug": "stopnotifications"
      },
      {
        "name": "isInitialized",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "Reports whether Bluetooth is initialized.\nNot available on **web**.",
        "complexTypes": [],
        "slug": "isinitialized"
      },
      {
        "name": "hasPermissions",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "Reports whether Bluetooth permissions have been granted.\nNot available on **web**.",
        "complexTypes": [],
        "slug": "haspermissions"
      },
      {
        "name": "checkPermissions",
        "signature": "() => Promise<PermissionStatus>",
        "parameters": [],
        "returns": "Promise<PermissionStatus>",
        "tags": [],
        "docs": "Reports whether the state of the permissions.\nNot available on **web**.",
        "complexTypes": [
          "PermissionStatus"
        ],
        "slug": "checkpermissions"
      },
      {
        "name": "requestPermissions",
        "signature": "() => Promise<PermissionStatus>",
        "parameters": [],
        "returns": "Promise<PermissionStatus>",
        "tags": [],
        "docs": "Request the permissions.\nNot available on **web**.",
        "complexTypes": [
          "PermissionStatus"
        ],
        "slug": "requestpermissions"
      },
      {
        "name": "enable",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "",
        "complexTypes": [],
        "slug": "enable"
      },
      {
        "name": "hasBluetoothScanPermission",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "",
        "complexTypes": [],
        "slug": "hasbluetoothscanpermission"
      },
      {
        "name": "hasBluetoothScanPermission",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "",
        "complexTypes": [],
        "slug": "hasbluetoothscanpermission"
      },
      {
        "name": "hasBluetoothConnectPermission",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "",
        "complexTypes": [],
        "slug": "hasbluetoothconnectpermission"
      },
      {
        "name": "hasAccessFineLocationPermission",
        "signature": "() => Promise<boolean>",
        "parameters": [],
        "returns": "Promise<boolean>",
        "tags": [],
        "docs": "",
        "complexTypes": [],
        "slug": "hasaccessfinelocationpermission"
      },
      {
        "name": "checkBluetoothPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "checkbluetoothpermission"
      },
      {
        "name": "checkBluetoothScanPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "checkbluetoothscanpermission"
      },
      {
        "name": "checkBluetoothConnectPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "checkbluetoothconnectpermission"
      },
      {
        "name": "checkAccessFineLocationPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "checkaccessfinelocationpermission"
      },
      {
        "name": "requestBluetoothPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "requestbluetoothpermission"
      },
      {
        "name": "requestBluetoothConnectPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "requestbluetoothconnectpermission"
      },
      {
        "name": "requestBluetoothScanPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "requestbluetoothscanpermission"
      },
      {
        "name": "requestAccessFineLocationPermission",
        "signature": "() => Promise<PermissionState>",
        "parameters": [],
        "returns": "Promise<PermissionState>",
        "tags": [],
        "docs": "",
        "complexTypes": [
          "PermissionState"
        ],
        "slug": "requestaccessfinelocationpermission"
      }
    ],
    "properties": []
  },
  "interfaces": [
    {
      "name": "InitializeOptions",
      "slug": "initializeoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "androidNeverForLocation",
          "tags": [
            {
              "text": "false",
              "name": "default"
            }
          ],
          "docs": "If your app doesn't use Bluetooth scan results to derive physical\nlocation information, you can strongly assert that your app\ndoesn't derive physical location. (Android only)\nRequires adding 'neverForLocation' to AndroidManifest.xml\nhttps://developer.android.com/guide/topics/connectivity/bluetooth/permissions#assert-never-for-location",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "withAlert",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "DisplayStrings",
      "slug": "displaystrings",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "scanning",
          "tags": [
            {
              "text": "0.0.1",
              "name": "since"
            },
            {
              "text": "\"Scanning...\"",
              "name": "default"
            },
            {
              "text": "\"Am Scannen...\"",
              "name": "example"
            }
          ],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "cancel",
          "tags": [
            {
              "text": "0.0.1",
              "name": "since"
            },
            {
              "text": "\"Cancel\"",
              "name": "default"
            },
            {
              "text": "\"Abbrechen\"",
              "name": "example"
            }
          ],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "availableDevices",
          "tags": [
            {
              "text": "0.0.1",
              "name": "since"
            },
            {
              "text": "\"Available devices\"",
              "name": "default"
            },
            {
              "text": "\"Verfügbare Geräte\"",
              "name": "example"
            }
          ],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "noDeviceFound",
          "tags": [
            {
              "text": "0.0.1",
              "name": "since"
            },
            {
              "text": "\"No device found\"",
              "name": "default"
            },
            {
              "text": "\"Kein Gerät gefunden\"",
              "name": "example"
            }
          ],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "BleDevice",
      "slug": "bledevice",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "deviceId",
          "tags": [],
          "docs": "ID of the device, which will be needed for further calls.\nOn **Android** this is the BLE MAC address.\nOn **iOS** and **web** it is an identifier.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "name",
          "tags": [],
          "docs": "Name of the peripheral device.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "uuids",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string[] | undefined"
        }
      ]
    },
    {
      "name": "RequestBleDeviceOptions",
      "slug": "requestbledeviceoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "services",
          "tags": [],
          "docs": "Filter devices by service UUIDs.\nUUIDs have to be specified as 128 bit UUID strings,\ne.g. ['0000180d-0000-1000-8000-00805f9b34fb']\nThere is a helper function to convert numbers to UUIDs.\ne.g. [numberToUUID(0x180f)]. (see [UUID format](#uuid-format))",
          "complexTypes": [],
          "type": "string[] | undefined"
        },
        {
          "name": "name",
          "tags": [],
          "docs": "Filter devices by name",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "namePrefix",
          "tags": [],
          "docs": "Filter devices by name prefix",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "optionalServices",
          "tags": [],
          "docs": "For **web**, all services that will be used have to be listed under services or optionalServices,\ne.g. [numberToUUID(0x180f)] (see [UUID format](#uuid-format))",
          "complexTypes": [],
          "type": "string[] | undefined"
        },
        {
          "name": "allowDuplicates",
          "tags": [],
          "docs": "Normally scans will discard the second and subsequent advertisements from a single device.\nIf you need to receive them, set allowDuplicates to true (only applicable in `requestLEScan`).\n(default: false)",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "scanMode",
          "tags": [],
          "docs": "Android scan mode (default: ScanMode.SCAN_MODE_BALANCED)",
          "complexTypes": [
            "ScanMode"
          ],
          "type": "ScanMode"
        }
      ]
    },
    {
      "name": "ScanResult",
      "slug": "scanresult",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "device",
          "tags": [],
          "docs": "The peripheral device that was found in the scan.\n**Android** and **web**: `device.name` is always identical to `localName`.\n**iOS**: `device.name` is identical to `localName` the first time a device is discovered, but after connecting `device.name` is the cached GAP name in subsequent scans.",
          "complexTypes": [
            "BleDevice"
          ],
          "type": "BleDevice"
        },
        {
          "name": "localName",
          "tags": [],
          "docs": "The name of the peripheral device from the advertisement data.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "rssi",
          "tags": [],
          "docs": "Received Signal Strength Indication.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "txPower",
          "tags": [],
          "docs": "Transmit power in dBm. A value of 127 indicates that it is not available.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "manufacturerData",
          "tags": [],
          "docs": "Manufacturer data, key is a company identifier and value is the data.",
          "complexTypes": [
            "DataView"
          ],
          "type": "{ [key: string]: DataView; } | undefined"
        },
        {
          "name": "serviceData",
          "tags": [],
          "docs": "Service data, key is a service UUID and value is the data.",
          "complexTypes": [
            "DataView"
          ],
          "type": "{ [key: string]: DataView; } | undefined"
        },
        {
          "name": "uuids",
          "tags": [],
          "docs": "Advertised services.",
          "complexTypes": [],
          "type": "string[] | undefined"
        },
        {
          "name": "rawAdvertisement",
          "tags": [],
          "docs": "Raw advertisement data (**Android** only).",
          "complexTypes": [
            "DataView"
          ],
          "type": "DataView"
        }
      ]
    },
    {
      "name": "DataView",
      "slug": "dataview",
      "docs": "",
      "tags": [],
      "methods": [
        {
          "name": "getFloat32",
          "signature": "(byteOffset: number, littleEndian?: boolean | undefined) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "",
              "type": "boolean | undefined"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Float32 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getfloat32"
        },
        {
          "name": "getFloat64",
          "signature": "(byteOffset: number, littleEndian?: boolean | undefined) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "",
              "type": "boolean | undefined"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Float64 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getfloat64"
        },
        {
          "name": "getInt8",
          "signature": "(byteOffset: number) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Int8 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getint8"
        },
        {
          "name": "getInt16",
          "signature": "(byteOffset: number, littleEndian?: boolean | undefined) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "",
              "type": "boolean | undefined"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Int16 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getint16"
        },
        {
          "name": "getInt32",
          "signature": "(byteOffset: number, littleEndian?: boolean | undefined) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "",
              "type": "boolean | undefined"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Int32 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getint32"
        },
        {
          "name": "getUint8",
          "signature": "(byteOffset: number) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Uint8 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getuint8"
        },
        {
          "name": "getUint16",
          "signature": "(byteOffset: number, littleEndian?: boolean | undefined) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "",
              "type": "boolean | undefined"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Uint16 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getuint16"
        },
        {
          "name": "getUint32",
          "signature": "(byteOffset: number, littleEndian?: boolean | undefined) => number",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be retrieved.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "",
              "type": "boolean | undefined"
            }
          ],
          "returns": "number",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be retrieved."
            }
          ],
          "docs": "Gets the Uint32 value at the specified byte offset from the start of the view. There is\r\nno alignment constraint; multi-byte values may be fetched from any offset.",
          "complexTypes": [],
          "slug": "getuint32"
        },
        {
          "name": "setFloat32",
          "signature": "(byteOffset: number, value: number, littleEndian?: boolean | undefined) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written.",
              "type": "boolean | undefined"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            },
            {
              "name": "param",
              "text": "littleEndian If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written."
            }
          ],
          "docs": "Stores an Float32 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setfloat32"
        },
        {
          "name": "setFloat64",
          "signature": "(byteOffset: number, value: number, littleEndian?: boolean | undefined) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written.",
              "type": "boolean | undefined"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            },
            {
              "name": "param",
              "text": "littleEndian If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written."
            }
          ],
          "docs": "Stores an Float64 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setfloat64"
        },
        {
          "name": "setInt8",
          "signature": "(byteOffset: number, value: number) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            }
          ],
          "docs": "Stores an Int8 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setint8"
        },
        {
          "name": "setInt16",
          "signature": "(byteOffset: number, value: number, littleEndian?: boolean | undefined) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written.",
              "type": "boolean | undefined"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            },
            {
              "name": "param",
              "text": "littleEndian If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written."
            }
          ],
          "docs": "Stores an Int16 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setint16"
        },
        {
          "name": "setInt32",
          "signature": "(byteOffset: number, value: number, littleEndian?: boolean | undefined) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written.",
              "type": "boolean | undefined"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            },
            {
              "name": "param",
              "text": "littleEndian If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written."
            }
          ],
          "docs": "Stores an Int32 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setint32"
        },
        {
          "name": "setUint8",
          "signature": "(byteOffset: number, value: number) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            }
          ],
          "docs": "Stores an Uint8 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setuint8"
        },
        {
          "name": "setUint16",
          "signature": "(byteOffset: number, value: number, littleEndian?: boolean | undefined) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written.",
              "type": "boolean | undefined"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            },
            {
              "name": "param",
              "text": "littleEndian If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written."
            }
          ],
          "docs": "Stores an Uint16 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setuint16"
        },
        {
          "name": "setUint32",
          "signature": "(byteOffset: number, value: number, littleEndian?: boolean | undefined) => void",
          "parameters": [
            {
              "name": "byteOffset",
              "docs": "The place in the buffer at which the value should be set.",
              "type": "number"
            },
            {
              "name": "value",
              "docs": "The value to set.",
              "type": "number"
            },
            {
              "name": "littleEndian",
              "docs": "If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written.",
              "type": "boolean | undefined"
            }
          ],
          "returns": "void",
          "tags": [
            {
              "name": "param",
              "text": "byteOffset The place in the buffer at which the value should be set."
            },
            {
              "name": "param",
              "text": "value The value to set."
            },
            {
              "name": "param",
              "text": "littleEndian If false or undefined, a big-endian value should be written,\r\notherwise a little-endian value should be written."
            }
          ],
          "docs": "Stores an Uint32 value at the specified byte offset from the start of the view.",
          "complexTypes": [],
          "slug": "setuint32"
        }
      ],
      "properties": [
        {
          "name": "buffer",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "ArrayBuffer"
          ],
          "type": "ArrayBuffer"
        },
        {
          "name": "byteLength",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "byteOffset",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "number"
        }
      ]
    },
    {
      "name": "ArrayBuffer",
      "slug": "arraybuffer",
      "docs": "Represents a raw buffer of binary data, which is used to store data for the\r\ndifferent typed arrays. ArrayBuffers cannot be read from or written to directly,\r\nbut can be passed to a typed array or DataView Object to interpret the raw\r\nbuffer as needed.",
      "tags": [],
      "methods": [
        {
          "name": "slice",
          "signature": "(begin: number, end?: number | undefined) => ArrayBuffer",
          "parameters": [
            {
              "name": "begin",
              "docs": "",
              "type": "number"
            },
            {
              "name": "end",
              "docs": "",
              "type": "number | undefined"
            }
          ],
          "returns": "ArrayBuffer",
          "tags": [],
          "docs": "Returns a section of an ArrayBuffer.",
          "complexTypes": [
            "ArrayBuffer"
          ],
          "slug": "slice"
        }
      ],
      "properties": [
        {
          "name": "byteLength",
          "tags": [],
          "docs": "Read-only. The length of the ArrayBuffer (in bytes).",
          "complexTypes": [],
          "type": "number"
        }
      ]
    },
    {
      "name": "TimeoutOptions",
      "slug": "timeoutoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "timeout",
          "tags": [],
          "docs": "Timeout in milliseconds for plugin call.\nDefault is 10000 for `connect` and 5000 for other plugin methods.",
          "complexTypes": [],
          "type": "number | undefined"
        }
      ]
    },
    {
      "name": "BleService",
      "slug": "bleservice",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "uuid",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "characteristics",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BleCharacteristic"
          ],
          "type": "BleCharacteristic[]"
        }
      ]
    },
    {
      "name": "BleCharacteristic",
      "slug": "blecharacteristic",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "uuid",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "properties",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BleCharacteristicProperties"
          ],
          "type": "BleCharacteristicProperties"
        },
        {
          "name": "descriptors",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BleDescriptor"
          ],
          "type": "BleDescriptor[]"
        }
      ]
    },
    {
      "name": "BleCharacteristicProperties",
      "slug": "blecharacteristicproperties",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "broadcast",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "read",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "writeWithoutResponse",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "write",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "notify",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "indicate",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "authenticatedSignedWrites",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "reliableWrite",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "writableAuxiliaries",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "extendedProperties",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "notifyEncryptionRequired",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "indicateEncryptionRequired",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "BleDescriptor",
      "slug": "bledescriptor",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "uuid",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "PermissionStatus",
      "slug": "permissionstatus",
      "docs": "",
      "tags": [],
      "methods": [
        {
          "name": "addEventListener",
          "signature": "<K extends \"change\">(type: K, listener: (this: PermissionStatus, ev: PermissionStatusEventMap[K]) => any, options?: boolean | AddEventListenerOptions | undefined) => void",
          "parameters": [
            {
              "name": "type",
              "docs": "",
              "type": "K"
            },
            {
              "name": "listener",
              "docs": "",
              "type": "(this: PermissionStatus, ev: PermissionStatusEventMap[K]) => any"
            },
            {
              "name": "options",
              "docs": "",
              "type": "boolean | AddEventListenerOptions | undefined"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.\n\nThe options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.\n\nWhen set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.\n\nWhen set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.\n\nWhen set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.\n\nThe event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.",
          "complexTypes": [
            "PermissionStatusEventMap",
            "K",
            "PermissionStatus",
            "AddEventListenerOptions"
          ],
          "slug": "addeventlistener"
        },
        {
          "name": "addEventListener",
          "signature": "(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | undefined) => void",
          "parameters": [
            {
              "name": "type",
              "docs": "",
              "type": "string"
            },
            {
              "name": "listener",
              "docs": "",
              "type": "EventListenerOrEventListenerObject"
            },
            {
              "name": "options",
              "docs": "",
              "type": "boolean | AddEventListenerOptions | undefined"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.\n\nThe options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.\n\nWhen set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.\n\nWhen set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.\n\nWhen set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.\n\nThe event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.",
          "complexTypes": [
            "EventListenerOrEventListenerObject",
            "AddEventListenerOptions"
          ],
          "slug": "addeventlistener"
        },
        {
          "name": "removeEventListener",
          "signature": "<K extends \"change\">(type: K, listener: (this: PermissionStatus, ev: PermissionStatusEventMap[K]) => any, options?: boolean | EventListenerOptions | undefined) => void",
          "parameters": [
            {
              "name": "type",
              "docs": "",
              "type": "K"
            },
            {
              "name": "listener",
              "docs": "",
              "type": "(this: PermissionStatus, ev: PermissionStatusEventMap[K]) => any"
            },
            {
              "name": "options",
              "docs": "",
              "type": "boolean | EventListenerOptions | undefined"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "Removes the event listener in target's event listener list with the same type, callback, and options.",
          "complexTypes": [
            "PermissionStatusEventMap",
            "K",
            "PermissionStatus",
            "EventListenerOptions"
          ],
          "slug": "removeeventlistener"
        },
        {
          "name": "removeEventListener",
          "signature": "(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions | undefined) => void",
          "parameters": [
            {
              "name": "type",
              "docs": "",
              "type": "string"
            },
            {
              "name": "listener",
              "docs": "",
              "type": "EventListenerOrEventListenerObject"
            },
            {
              "name": "options",
              "docs": "",
              "type": "boolean | EventListenerOptions | undefined"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "Removes the event listener in target's event listener list with the same type, callback, and options.",
          "complexTypes": [
            "EventListenerOrEventListenerObject",
            "EventListenerOptions"
          ],
          "slug": "removeeventlistener"
        }
      ],
      "properties": [
        {
          "name": "onchange",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "PermissionStatus",
            "Event"
          ],
          "type": "((this: PermissionStatus, ev: Event) => any) | null"
        },
        {
          "name": "state",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "PermissionState"
          ],
          "type": "PermissionState"
        }
      ]
    },
    {
      "name": "PermissionStatusEventMap",
      "slug": "permissionstatuseventmap",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "\"change\"",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "Event"
          ],
          "type": "Event"
        }
      ]
    },
    {
      "name": "Event",
      "slug": "event",
      "docs": "An event which takes place in the DOM.",
      "tags": [],
      "methods": [
        {
          "name": "composedPath",
          "signature": "() => EventTarget[]",
          "parameters": [],
          "returns": "EventTarget[]",
          "tags": [],
          "docs": "Returns the invocation target objects of event's path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root's mode is \"closed\" that are not reachable from event's currentTarget.",
          "complexTypes": [
            "EventTarget"
          ],
          "slug": "composedpath"
        },
        {
          "name": "initEvent",
          "signature": "(type: string, bubbles?: boolean | undefined, cancelable?: boolean | undefined) => void",
          "parameters": [
            {
              "name": "type",
              "docs": "",
              "type": "string"
            },
            {
              "name": "bubbles",
              "docs": "",
              "type": "boolean | undefined"
            },
            {
              "name": "cancelable",
              "docs": "",
              "type": "boolean | undefined"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "slug": "initevent"
        },
        {
          "name": "preventDefault",
          "signature": "() => void",
          "parameters": [],
          "returns": "void",
          "tags": [],
          "docs": "If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.",
          "complexTypes": [],
          "slug": "preventdefault"
        },
        {
          "name": "stopImmediatePropagation",
          "signature": "() => void",
          "parameters": [],
          "returns": "void",
          "tags": [],
          "docs": "Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.",
          "complexTypes": [],
          "slug": "stopimmediatepropagation"
        },
        {
          "name": "stopPropagation",
          "signature": "() => void",
          "parameters": [],
          "returns": "void",
          "tags": [],
          "docs": "When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.",
          "complexTypes": [],
          "slug": "stoppropagation"
        }
      ],
      "properties": [
        {
          "name": "bubbles",
          "tags": [],
          "docs": "Returns true or false depending on how event was initialized. True if event goes through its target's ancestors in reverse tree order, and false otherwise.",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "cancelBubble",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "cancelable",
          "tags": [],
          "docs": "Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "composed",
          "tags": [],
          "docs": "Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise.",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "currentTarget",
          "tags": [],
          "docs": "Returns the object whose event listener's callback is currently being invoked.",
          "complexTypes": [
            "EventTarget"
          ],
          "type": "EventTarget | null"
        },
        {
          "name": "defaultPrevented",
          "tags": [],
          "docs": "Returns true if preventDefault() was invoked successfully to indicate cancelation, and false otherwise.",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "eventPhase",
          "tags": [],
          "docs": "Returns the event's phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "isTrusted",
          "tags": [],
          "docs": "Returns true if event was dispatched by the user agent, and false otherwise.",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "returnValue",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "srcElement",
          "tags": [
            {
              "name": "deprecated"
            }
          ],
          "docs": "",
          "complexTypes": [
            "EventTarget"
          ],
          "type": "EventTarget | null"
        },
        {
          "name": "target",
          "tags": [],
          "docs": "Returns the object to which event is dispatched (its target).",
          "complexTypes": [
            "EventTarget"
          ],
          "type": "EventTarget | null"
        },
        {
          "name": "timeStamp",
          "tags": [],
          "docs": "Returns the event's timestamp as the number of milliseconds measured relative to the time origin.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "type",
          "tags": [],
          "docs": "Returns the type of event, e.g. \"click\", \"hashchange\", or \"submit\".",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "AT_TARGET",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "BUBBLING_PHASE",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "CAPTURING_PHASE",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "NONE",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "number"
        }
      ]
    },
    {
      "name": "EventTarget",
      "slug": "eventtarget",
      "docs": "EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them.",
      "tags": [],
      "methods": [
        {
          "name": "addEventListener",
          "signature": "(type: string, listener: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions | undefined) => void",
          "parameters": [
            {
              "name": "type",
              "docs": "",
              "type": "string"
            },
            {
              "name": "listener",
              "docs": "",
              "type": "EventListenerOrEventListenerObject | null"
            },
            {
              "name": "options",
              "docs": "",
              "type": "boolean | AddEventListenerOptions | undefined"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.\n\nThe options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.\n\nWhen set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.\n\nWhen set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.\n\nWhen set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.\n\nThe event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.",
          "complexTypes": [
            "EventListenerOrEventListenerObject",
            "AddEventListenerOptions"
          ],
          "slug": "addeventlistener"
        },
        {
          "name": "dispatchEvent",
          "signature": "(event: Event) => boolean",
          "parameters": [
            {
              "name": "event",
              "docs": "",
              "type": "Event"
            }
          ],
          "returns": "boolean",
          "tags": [],
          "docs": "Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.",
          "complexTypes": [
            "Event"
          ],
          "slug": "dispatchevent"
        },
        {
          "name": "removeEventListener",
          "signature": "(type: string, callback: EventListenerOrEventListenerObject | null, options?: boolean | EventListenerOptions | undefined) => void",
          "parameters": [
            {
              "name": "type",
              "docs": "",
              "type": "string"
            },
            {
              "name": "callback",
              "docs": "",
              "type": "EventListenerOrEventListenerObject | null"
            },
            {
              "name": "options",
              "docs": "",
              "type": "boolean | EventListenerOptions | undefined"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "Removes the event listener in target's event listener list with the same type, callback, and options.",
          "complexTypes": [
            "EventListenerOrEventListenerObject",
            "EventListenerOptions"
          ],
          "slug": "removeeventlistener"
        }
      ],
      "properties": []
    },
    {
      "name": "EventListener",
      "slug": "eventlistener",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": []
    },
    {
      "name": "EventListenerObject",
      "slug": "eventlistenerobject",
      "docs": "",
      "tags": [],
      "methods": [
        {
          "name": "handleEvent",
          "signature": "(evt: Event) => void",
          "parameters": [
            {
              "name": "evt",
              "docs": "",
              "type": "Event"
            }
          ],
          "returns": "void",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "Event"
          ],
          "slug": "handleevent"
        }
      ],
      "properties": []
    },
    {
      "name": "AddEventListenerOptions",
      "slug": "addeventlisteneroptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "once",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "passive",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "EventListenerOptions",
      "slug": "eventlisteneroptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "capture",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    }
  ],
  "enums": [
    {
      "name": "ScanMode",
      "slug": "scanmode",
      "members": [
        {
          "name": "SCAN_MODE_LOW_POWER",
          "value": "0",
          "tags": [],
          "docs": "Perform Bluetooth LE scan in low power mode. This mode is enforced if the scanning application is not in foreground.\nhttps://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_POWER"
        },
        {
          "name": "SCAN_MODE_BALANCED",
          "value": "1",
          "tags": [],
          "docs": "Perform Bluetooth LE scan in balanced power mode. (default) Scan results are returned at a rate that provides a good trade-off between scan frequency and power consumption.\nhttps://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_BALANCED"
        },
        {
          "name": "SCAN_MODE_LOW_LATENCY",
          "value": "2",
          "tags": [],
          "docs": "Scan using highest duty cycle. It's recommended to only use this mode when the application is running in the foreground.\nhttps://developer.android.com/reference/android/bluetooth/le/ScanSettings#SCAN_MODE_LOW_LATENCY"
        }
      ]
    }
  ],
  "typeAliases": [
    {
      "name": "EventListenerOrEventListenerObject",
      "slug": "eventlisteneroreventlistenerobject",
      "docs": "",
      "types": [
        {
          "text": "EventListener",
          "complexTypes": [
            "EventListener"
          ]
        },
        {
          "text": "EventListenerObject",
          "complexTypes": [
            "EventListenerObject"
          ]
        }
      ]
    },
    {
      "name": "PermissionState",
      "slug": "permissionstate",
      "docs": "",
      "types": [
        {
          "text": "\"denied\"",
          "complexTypes": []
        },
        {
          "text": "\"granted\"",
          "complexTypes": []
        },
        {
          "text": "\"prompt\"",
          "complexTypes": []
        }
      ]
    }
  ],
  "pluginConfigs": [
    {
      "name": "BluetoothLe",
      "slug": "bluetoothle",
      "properties": [
        {
          "name": "displayStrings",
          "tags": [
            {
              "text": "0.0.1",
              "name": "since"
            },
            {
              "text": "{\n\"scanning\": \"Scanning...\",\n\"cancel\": \"Cancel\",\n\"availableDevices\": \"Available devices\",\n\"noDeviceFound\": \"No device found\"\n}",
              "name": "default"
            },
            {
              "text": "{\nscanning: \"Am Scannen...\",\ncancel: \"Abbrechen\",\navailableDevices: \"Verfügbare Geräte\",\nnoDeviceFound: \"Kein Gerät gefunden\",\n}",
              "name": "example"
            }
          ],
          "docs": "The strings that are displayed in the device selection dialog on iOS and Android when using `requestDevice()`.",
          "complexTypes": [
            "DisplayStrings"
          ],
          "type": "DisplayStrings"
        }
      ],
      "docs": "These config values are available:"
    }
  ]
}